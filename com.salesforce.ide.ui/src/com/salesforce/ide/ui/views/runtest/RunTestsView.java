/*******************************************************************************
 * Copyright (c) 2015 Salesforce.com, inc..
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Salesforce.com, inc. - initial API and implementation
 ******************************************************************************/

package com.salesforce.ide.ui.views.runtest;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.log4j.Logger;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IMarker;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jface.resource.FontRegistry;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.graphics.Font;
import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Tree;
import org.eclipse.swt.widgets.TreeItem;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.ide.IDE;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Lists;
import com.salesforce.ide.apex.internal.core.ApexTestsUtils;
import com.salesforce.ide.core.internal.context.ContainerDelegate;
import com.salesforce.ide.core.internal.utils.DialogUtils;
import com.salesforce.ide.core.internal.utils.QualifiedNames;
import com.salesforce.ide.core.internal.utils.ResourceProperties;
import com.salesforce.ide.core.internal.utils.Utils;
import com.salesforce.ide.core.model.ApexCodeLocation;
import com.salesforce.ide.core.project.ForceProject;
import com.salesforce.ide.core.remote.ForceConnectionException;
import com.salesforce.ide.core.remote.ForceRemoteException;
import com.salesforce.ide.core.remote.HTTPAdapter;
import com.salesforce.ide.core.remote.HTTPAdapter.HTTPMethod;
import com.salesforce.ide.core.remote.HTTPConnection;
import com.salesforce.ide.core.remote.PromiseableJob;
import com.salesforce.ide.core.remote.ToolingStubExt;
import com.salesforce.ide.core.remote.tooling.ApexLogCommand;
import com.salesforce.ide.core.remote.tooling.ApexLogTransport;
import com.salesforce.ide.core.remote.tooling.Limit;
import com.salesforce.ide.core.remote.tooling.LimitsCommand;
import com.salesforce.ide.core.remote.tooling.LimitsTransport;
import com.salesforce.ide.core.remote.tooling.RunTestsCommand;
import com.salesforce.ide.core.remote.tooling.RunTestsSyncCodeCoverage;
import com.salesforce.ide.core.remote.tooling.RunTestsSyncCodeCoverageWarning;
import com.salesforce.ide.core.remote.tooling.RunTestsSyncFailure;
import com.salesforce.ide.core.remote.tooling.RunTestsSyncResponse;
import com.salesforce.ide.core.remote.tooling.RunTestsSyncSuccess;
import com.salesforce.ide.core.remote.tooling.RunTestsTransport;
import com.salesforce.ide.core.remote.tooling.TraceFlagUtil;
import com.salesforce.ide.ui.internal.utils.UIConstants;
import com.salesforce.ide.ui.internal.utils.UIUtils;
import com.salesforce.ide.ui.views.BaseViewPart;
import com.sforce.soap.tooling.AggregateResult;
import com.sforce.soap.tooling.ApexCodeCoverageAggregate;
import com.sforce.soap.tooling.ApexLog;
import com.sforce.soap.tooling.ApexLogLevel;
import com.sforce.soap.tooling.ApexOrgWideCoverage;
import com.sforce.soap.tooling.ApexTestOutcome;
import com.sforce.soap.tooling.ApexTestQueueItem;
import com.sforce.soap.tooling.ApexTestResult;
import com.sforce.soap.tooling.AsyncApexJobStatus;
import com.sforce.soap.tooling.LogCategory;
import com.sforce.soap.tooling.QueryResult;
import com.sforce.soap.tooling.SObject;

/**
 * Responsible for running tests, getting results, and updating the UI with the test results.
 * The actual view is generated by RunTestsViewComposite.java.
 * 
 * @author jwidjaja
 *
 */
public class RunTestsView extends BaseViewPart {
    private static final Logger logger = Logger.getLogger(RunTestsView.class);
    
    private static RunTestsView INSTANCE = null;
    
    @VisibleForTesting
    public ReentrantLock lock = new ReentrantLock();
    @VisibleForTesting
    public ForceProject forceProject = null;
    @VisibleForTesting
    public ToolingStubExt toolingStubExt = null;
    
    private RunTestsViewComposite runTestComposite = null;
    private IProject project = null;
    private HTTPConnection toolingRESTConnection = null;
    private ISelectionListener fPostSelectionListener = null;
    private TraceFlagUtil tfUtil = null;
    
    public RunTestsView() {
        super();
        setSelectionListener();
        
        INSTANCE = this;
    }
    
    public static RunTestsView getInstance() {
    	if (Utils.isEmpty(INSTANCE)) {
    		// We use Display.syncExec because getting a view has to be done
    		// on a UI thread.
    		Display display = PlatformUI.getWorkbench().getDisplay();
    		if (Utils.isEmpty(display)) return INSTANCE;
    		
    		display.syncExec(new Runnable() {
				@Override
				public void run() {
					try {
						INSTANCE = (RunTestsView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(UIConstants.RUN_TEST_VIEW_ID);
					} catch (PartInitException e) {}
				}
			});
    	}
    	
    	return INSTANCE;
    }
    
    /**
     * Is there a test run in progress? If yes, this method
     * returns false. If no, this method returns true.
     */
    public boolean canRun() {
    	return (lock != null && !lock.isLocked());
    }
    
    /**
     * Check if there is an existing active Trace Flag.
     * @param project
     */
    public boolean hasExistingTraceFlag(IProject project) {
    	ForceProject fp = materializeForceProject(project);
    	TraceFlagUtil tf = getTraceFlagUtil(fp);
    	return tf.hasActiveTraceFlag();
    }
    
    /**
     * Show error message to user
     * @param title
     * @param solution
     */
    private void throwErrorMsg(final String title, final String solution) {
		if (Utils.isNotEmpty(title) && Utils.isNotEmpty(solution)) {
			Display display = PlatformUI.getWorkbench().getDisplay();
			display.asyncExec(new Runnable() {
				@Override
				public void run() {
					DialogUtils.getInstance().okMessage(title, solution);
				}
			});
			
		}
	}
    
    /**
     * Run the tests, get the results, and update the UI.
     * @param project
     * @param testResources
     * @param testsInJson
     * @param totalTestMethods
     * @param isAsync
     * @param isDebugging
     * @param monitor
     */
    public void runTests(final IProject project, Map<IResource, List<String>> testResources, 
    		String testsInJson, int totalTestMethods, boolean isAsync, boolean isDebugging, 
    		boolean shouldEnableLogging, Map<LogCategory, ApexLogLevel> logLevels, IProgressMonitor monitor) {
    	
    	lock.lock();
    	
    	forceProject = materializeForceProject(project);
    	if (Utils.isEmpty(forceProject)) {
    		logger.error("Unable to find Force.com project");
    		lock.unlock();
    		return;
    	}
    	
    	tfUtil = getTraceFlagUtil(forceProject);
    	String debugLevelId = null, traceFlagId = null;
    	
    	try {
    		prepareForRunningTests();
    		
    		// Set user TraceFlag if launch config enabled logging
        	if (shouldEnableLogging) {
        		String userName = forceProject.getUserName();
            	String userId = tfUtil.getUserId(userName);
            	debugLevelId = tfUtil.insertDebugLevel(RunTestsConstants.DEBUG_LEVEL_NAME + System.currentTimeMillis(), logLevels);
            	traceFlagId = tfUtil.insertTraceFlag(userId, RunTestsConstants.TF_LENGTH_MINS, debugLevelId);
            	tfUtil.automateTraceFlagExtension(traceFlagId, RunTestsConstants.TF_INTERVAL_MINS, 
            			RunTestsConstants.TF_LENGTH_MINS);
        	}
        	
        	if (!monitor.isCanceled()) {
            	// Submit the tests for execution
            	String enqueueResult = enqueueTests(testsInJson, isAsync, isDebugging);
            	
            	if (Utils.isNotEmpty(enqueueResult) && isAsync) {
            		// If it's an async run, the enqueue result is an async test run ID, so we poll for test results
            		List<ApexTestResult> testResults = getTestResults(enqueueResult, totalTestMethods, monitor);
            		// Whether or not user aborted, we want to show whatever test results we got back
                	processAsyncTestResults(project, testResources, testResults);
                	// Display code coverage from ApexCodeCoverageAggregate & ApexOrgWideCoverage
                	displayAsyncCodeCoverage();
            	} else if (Utils.isNotEmpty(enqueueResult) && !isAsync) {
            		/*
            		 * Sync test runs do create ApexTestResult objects, but there's no way to query the
            		 * right ones for this test run because they don't have a sync test run ID, only async
            		 * test run ID. So, we have to rely on the response of runTestsSynchronous.
            		 */
            		ObjectMapper mapper = new ObjectMapper();
		    		RunTestsSyncResponse testResults;
					try {
						testResults = mapper.readValue(enqueueResult, RunTestsSyncResponse.class);
						// Test results are returned all at once
						updateProgress(0, totalTestMethods, testResults.getNumTestsRun());
						// Tests were submitted in alphabetical order. We're relying on the
						// server to return test results in the same order to avoid sorting
						// the results
						processSyncTestResults(project, testResources, testResults);
						displaySyncCodeCoverage(testResults);
					} catch (IOException e) {
						logger.error(String.format("Problem reading test result: %s", enqueueResult));
					}
            	}
        	}
    	} finally {
    		// Clean up TraceFlag if launch config enabled logging
    		if (shouldEnableLogging) {
    			tfUtil.removeTraceFlagJobs();
    			tfUtil.deleteTraceflagAndDebugLevel(traceFlagId, debugLevelId);
    		}
    		
    		lock.unlock();
    	}
    }
    
    /**
     * Do some UI prep work
     */
    @VisibleForTesting
	public void prepareForRunningTests() {
    	Display display = PlatformUI.getWorkbench().getDisplay();
    	display.syncExec(new Runnable() {
			@Override
			public void run() {
				setProject(project);
				runTestComposite.clearAll();
			}
    	});
    }
    
    /**
	 * Get a ForceProject from an IProject.
	 * @param project
	 * @return ForceProject
	 */
    @VisibleForTesting
	public ForceProject materializeForceProject(IProject project) {
		if (Utils.isEmpty(project) || !project.exists())
            return null;

        ForceProject forceProject =
                ContainerDelegate.getInstance().getServiceLocator().getProjectService().getForceProject(project);
        return forceProject;
	}
    
    /**
     * Create a new TraceFlagUtil
     * @param forceProject
     */
    @VisibleForTesting
	public TraceFlagUtil getTraceFlagUtil(ForceProject forceProject) {
    	return new TraceFlagUtil(forceProject);
    }
	
	/**
	 * Enqueue a tests array to Tooling's runTestsAsynchronous.
	 * @param testsInJson
	 * @param isAsync
	 * @param isDebugging
	 * @return The test run ID if valid async run. 
	 * The test results if valid sync run. Null otherwise.
	 */
    @VisibleForTesting
	public String enqueueTests(String testsInJson, boolean isAsync, boolean isDebugging) {
		String response = null;
		
		if (Utils.isEmpty(forceProject)) {
			return null;
		}
		
		try {
			int timeoutVal = getConnTimeoutVal(isAsync, isDebugging);
			initializeConnection(forceProject, timeoutVal);
			
			PromiseableJob<String> job = getRunTestsCommand(testsInJson, isAsync);
			job.schedule();
			
			job.join();
			response = job.getAnswer();
			if (Utils.isEmpty(response)) {
				throwErrorMsg(Messages.RunTestsView_ErrorStartingTestsTitle, 
						Messages.RunTestsView_ErrorStartingTestsSolution);
			}
		} catch (Exception e) {
			logger.error(String.format("Tests array: %s. Error message: %s", testsInJson, e.getMessage()));
			throwErrorMsg(Messages.RunTestsView_ErrorStartingTestsTitle, 
					Messages.RunTestsView_ErrorStartingTestsSolution);
		}
		
		return response;
	}
	
	/**
	 * Get connection timeout value depending on
	 * test mode and debugging status.
	 * @param isAsync
	 * @param isDebugging
	 * @return Timeout value
	 */
    @VisibleForTesting
	public int getConnTimeoutVal(boolean isAsync, boolean isDebugging) {
		return (isAsync ? RunTestsConstants.ASYNC_TIMEOUT : 
			(isDebugging ? RunTestsConstants.SYNC_WITH_DEBUG_TIMEOUT : 
				RunTestsConstants.SYNC_WITHOUT_DEBUG_TIMEOUT));
	}
	
	/**
	 * Create the job to submit to Tooling API's run tests endpoint.
	 * @param testsInJson
	 * @param isAsync
	 * @return Promiseable job
	 */
    @VisibleForTesting
	public PromiseableJob<String> getRunTestsCommand(String testsInJson, boolean isAsync) {
		return new RunTestsCommand(new HTTPAdapter<>(
				String.class, new RunTestsTransport(toolingRESTConnection, isAsync), HTTPMethod.POST), testsInJson);
	}
	
	/**
	 * Retrieve test results for the given test run ID.
	 * @param testRunId
	 * @param totalTestMethods
	 * @param monitor
	 * @return List of ApexTestResult
	 */
    @VisibleForTesting
	public List<ApexTestResult> getTestResults(String testRunId, final int totalTestMethods, IProgressMonitor monitor) {
		List<ApexTestResult> testResults = Lists.newArrayList();
		if (Utils.isEmpty(forceProject) || Utils.isEmpty(testRunId)) return testResults;
		testRunId = testRunId.replace("\"", "");
		
		try {
			initializeConnection(forceProject);
			
			// Get remaining daily API requests
			Limit dailyApiRequests = getApiLimit(forceProject, LimitsCommand.Type.DailyApiRequests);
			if (dailyApiRequests == null) {
				return testResults;
			}
			
			float apiRequestsRemaining = (dailyApiRequests.getRemaining() * 100.0f) / dailyApiRequests.getMax();
			if (apiRequestsRemaining <= 0) {
				return testResults;
			}
			
			// Poll for remaining test cases to be executed
			int totalTestDone = 0;
			QueryResult qr = null;
			// No timeout here because we don't know how long a test run can be.
			// If user wants to exit, then they can cancel the launch config.
			while (totalTestDone < totalTestMethods) {
				// Query for number of finished tests in specified test run
				qr = toolingStubExt.query(String.format(RunTestsConstants.QUERY_TESTRESULT_COUNT, testRunId));
				
				// Update finished test counter
				if (Utils.isNotEmpty(qr) && qr.getSize() == 1) {
					SObject sObj = qr.getRecords()[0];
					if (sObj instanceof AggregateResult) {
						AggregateResult aggRes = (AggregateResult) sObj;
						Object expr0 = aggRes.getField("expr0");
						totalTestDone = (int) expr0;
						updateProgress(0, totalTestMethods, totalTestDone);
					}
				}
				
				// User wants to abort so we'll tell the server to abort the test run
				// and stop polling for test results. There may be some finished test results
				// so try to query those and update UI if necessary.
				if (monitor.isCanceled()) {
					abortTestRun(testRunId);
					break;
				}
				
				// Wait according to the interval
				int wait = getPollInterval(totalTestMethods - totalTestDone, apiRequestsRemaining);
				Thread.sleep(wait);
			}
			
			// Get all test results in the specified test run
			qr = toolingStubExt.query(String.format(RunTestsConstants.QUERY_TESTRESULT, testRunId));
			if (qr != null && qr.getSize() > 0) {
				updateProgress(0, totalTestMethods, qr.getSize());
				for (SObject sObj : qr.getRecords()) {
					ApexTestResult testResult = (ApexTestResult) sObj;
					testResults.add(testResult);
				}
			}
		} catch (Exception e) {
			logger.error(e.getMessage());
			throwErrorMsg(Messages.RunTestsView_ErrorGetAsyncTestResultsTitle, 
					Messages.RunTestsView_ErrorGetAsyncTestResultsSolution);
		}
		
		return testResults;
	}
	
	/**
	 * Get a specific API Limit
	 * @param type
	 * @return Limit
	 * @see Limit.java
	 */
    @VisibleForTesting
	public Limit getApiLimit(ForceProject forceProject, LimitsCommand.Type type) {
		try {
			initializeConnection(forceProject);
			
			PromiseableJob<Map<String, Limit>> job = new LimitsCommand(new HTTPAdapter<>(
					String.class, new LimitsTransport(toolingRESTConnection), HTTPMethod.GET));
			job.schedule();
			
			try {
				job.join();
				Map<String, Limit> limits = job.getAnswer();
				if (limits != null && limits.size() > 0) {
					return limits.get(type.toString());
				}
			} catch (InterruptedException e) {
				logger.error("Failed to enqueue test run", e);
			}
		} catch (ForceConnectionException | ForceRemoteException e) {
			logger.error("Failed to connect to Tooling API", e);
		}
		
		return null;
	}
	
	/**
	 * Get the appropriate poll interval depending on the number of tests remaining
	 * and the number of API requests remaining. The higher the number of tests remaining, the slower
	 * we should poll. The higher the number of remaining API requests, the faster we should poll.
	 * @param totalTestRemaining
	 * @param apiRequestsRemaining
	 * @return A poll interval
	 */
    @VisibleForTesting
	public int getPollInterval(int totalTestRemaining, float apiRequestsRemaining) {
		int intervalA = RunTestsConstants.POLL_SLOW, intervalB = RunTestsConstants.POLL_SLOW;
		
		if (totalTestRemaining <= 10) {
			intervalA = RunTestsConstants.POLL_FAST;
		} else if (totalTestRemaining <= 50) {
			intervalA = RunTestsConstants.POLL_MED;
		} else {
			intervalA = RunTestsConstants.POLL_SLOW;
		}
		
		if (apiRequestsRemaining <= 25f) {
			intervalB = RunTestsConstants.POLL_SLOW;
		} else if (apiRequestsRemaining <= 50f) {
			intervalB = RunTestsConstants.POLL_MED;
		} else {
			intervalB = RunTestsConstants.POLL_FAST;
		}
		
		return (intervalA + intervalB) / 2;
	}
	
	/**
	 * Update the progress bar to show user the number of tests finished.
	 * @param min
	 * @param max
	 * @param cur
	 */
    @VisibleForTesting
	public void updateProgress(final int min, final int max, final int cur) {
		Display display = PlatformUI.getWorkbench().getDisplay();
		display.syncExec(new Runnable(){
			@Override
			public void run() {
				if (Utils.isNotEmpty(runTestComposite)) {
					runTestComposite.setProgress(min, max, cur);
				}
			}
		});
	}
	
	/**
	 * Abort all ApexTestQueueItem with the same test run ID.
	 * @param testRunId
	 */
    @VisibleForTesting
	public boolean abortTestRun(String testRunId) {
		if (Utils.isEmpty(forceProject) || Utils.isEmpty(testRunId)) {
			return false;
		}
		
		try {
			initializeConnection(forceProject);
			
			// Get all ApexTestQueueItem in the test run
			QueryResult qr = toolingStubExt.query(String.format(RunTestsConstants.QUERY_APEX_TEST_QUEUE_ITEM, testRunId));
			if (Utils.isEmpty(qr) || qr.getSize() == 0) return false;
			
			// Update status to Aborted
			List<ApexTestQueueItem> abortedList = Lists.newArrayList();
			for (SObject sObj : qr.getRecords()) {
				ApexTestQueueItem atqi = (ApexTestQueueItem) sObj;
				// If the queue item is not done yet, abort them
				if (!atqi.getStatus().equals(AsyncApexJobStatus.Completed) && !atqi.getStatus().equals(AsyncApexJobStatus.Failed)) {
					atqi.setStatus(AsyncApexJobStatus.Aborted);
					abortedList.add(atqi);
				}
			}
			
			// Update in chunks because there is a limit to how many we can update in one call
			if (!abortedList.isEmpty()) {
				for (List<ApexTestQueueItem> subList : Lists.partition(abortedList, 200)) {
					ApexTestQueueItem[] abortedArray = subList.toArray(new ApexTestQueueItem[subList.size()]);
					toolingStubExt.update(abortedArray);
				}
				return true;
			}
		} catch (ForceConnectionException | ForceRemoteException e) {
			logger.error("Failed to connect to Tooling API", e);
		}
		
		return false;
	}
    
    /**
     * Update the UI with the test results for an asynchronous test run.
     * @param project
     * @param testResources
     * @param testResults
     */
    @VisibleForTesting
	public void processAsyncTestResults(final IProject project, final Map<IResource, List<String>> testResources, 
    		final List<ApexTestResult> testResults) {
    	if (Utils.isEmpty(project) || Utils.isEmpty(testResources) || Utils.isEmpty(testResults)) {
			return;
		}
    	
    	Display display = PlatformUI.getWorkbench().getDisplay();
    	display.syncExec(new Runnable() {
			@Override
			public void run() {
				// Map of tree items whose key is apex class id and the value is the tree item
		    	Map<String, TreeItem> testClassNodes = new HashMap<String, TreeItem>();
		    	
		    	FontRegistry registry = new FontRegistry();
		        Font boldFont = registry.getBold(Display.getCurrent().getSystemFont().getFontData()[0].getName());
		    	
		        // Reset tree
		    	Tree resultsTree = runTestComposite.getTree();
		    	resultsTree.removeAll();
		    	
		    	// Add each test result to the tree
		    	for (ApexTestResult testResult: testResults) {
		    		// Create or find the tree node for the test class
		    		String classId = testResult.getApexClassId();
		    		if (!testClassNodes.containsKey(classId)) {
		    			TreeItem newClassNode = createTestClassTreeItem(resultsTree, testResources, boldFont, classId);
		    			
		    			testClassNodes.put(classId, newClassNode);
		    		}
		    		
		    		// Add the a test method tree node to the test class tree node
		    		TreeItem classNode = testClassNodes.get(classId);
		    		String className = classNode.getText();
		    		
		    		// Create a tree item for the test method and save the test result
		    		TreeItem newTestMethodNode = createTestMethodTreeItem(classNode, testResult, className);
	    			// Set the color and icon of test method tree node based on test outcome
	    			setColorAndIconForNode(newTestMethodNode, testResult.getOutcome());
	    			// Update the color & icon of class tree node only if the test method
	    			// outcome is worse than what the class tree node indicates
	    			setColorAndIconForTheWorse(classNode, testResult.getOutcome());
		    	}
		    	
		    	// Expand the test classes that did not pass
		    	expandProblematicTestClasses(resultsTree);
			}
    	});
    }
    
    /**
     * Update the UI with the test results for an synchronous test run.
     * @param project
     * @param testResources
     * @param testResults
     */
    @VisibleForTesting
	public void processSyncTestResults(final IProject project, final Map<IResource, List<String>> testResources, final RunTestsSyncResponse testResults) {
    	if (Utils.isEmpty(project) || Utils.isEmpty(testResources) || Utils.isEmpty(testResults)) {
			return;
		}
    	
    	Display display = PlatformUI.getWorkbench().getDisplay();
    	display.syncExec(new Runnable() {
			@Override
			public void run() {
		    	// Map of tree items whose key is apex class id and the value is the tree item
				Map<String, TreeItem> testClassNodes = new HashMap<String, TreeItem>();
				
				FontRegistry registry = new FontRegistry();
				Font boldFont = registry.getBold(Display.getCurrent().getSystemFont().getFontData()[0].getName());
				
				// Reset tree
				Tree resultsTree = runTestComposite.getTree();
				resultsTree.removeAll();
				
				for (RunTestsSyncSuccess testPassed : testResults.getSuccesses()) {
					// Create or find the tree node for the test class
					final String classId = testPassed.getId();
					final String className = testPassed.getName();
					if (!testClassNodes.containsKey(classId)) {
						TreeItem newClassNode = createTestClassTreeItem(resultsTree, testResources, boldFont, classId);
						testClassNodes.put(classId, newClassNode);
					}
					
					// Add the a test method tree node to the test class tree node
					TreeItem classNode = testClassNodes.get(classId);
					// Create a tree item for the test method and save the test result
					TreeItem newTestMethodNode = createTestMethodTreeItem(classNode, className, 
							testPassed.getMethodName(), "", "", testResults.getApexLogId());
					// Set the color and icon of test method tree node based on test outcome
					setColorAndIconForNode(newTestMethodNode, ApexTestOutcome.Pass);
				}
				
				for (RunTestsSyncFailure testFailed : testResults.getFailures()) {
					// Create or find the tree node for the test class
					final String classId = testFailed.getId();
					final String className = testFailed.getName();
					if (!testClassNodes.containsKey(classId)) {
						TreeItem newClassNode = createTestClassTreeItem(resultsTree, testResources, boldFont, classId);
						testClassNodes.put(classId, newClassNode);
					}
					
					// Add the a test method tree node to the test class tree node
					TreeItem classNode = testClassNodes.get(classId);
					// Create a tree item for the test method and save the test result
					TreeItem newTestMethodNode = createTestMethodTreeItem(classNode, className, 
							testFailed.getMethodName(), testFailed.getMessage(), testFailed.getStackTrace(), 
							testResults.getApexLogId());
					// Set the color and icon of test method tree node based on test outcome
					setColorAndIconForNode(newTestMethodNode, ApexTestOutcome.Fail);
					// Update the color & icon of class tree node only if the test method
					// outcome is worse than what the class tree node indicates
					setColorAndIconForTheWorse(classNode, ApexTestOutcome.Fail);
				}
				
				// Expand the test classes that did not pass
				expandProblematicTestClasses(resultsTree);
			}
    	});
    }
    
    /**
     * Display org wide and individual test class code coverage
     * from ApexOrgWideCoverage & ApexCodeCoverageAgg
     */
    @VisibleForTesting
	public void displayAsyncCodeCoverage() {
    	if (Utils.isEmpty(forceProject) || Utils.isEmpty(runTestComposite)) return;
    	
    	Display display = PlatformUI.getWorkbench().getDisplay();
    	display.syncExec(new Runnable() {
			@Override
			public void run() {
				List<CodeCovResult> ccResults = Lists.newArrayList();
				
				ApexOrgWideCoverage orgWide = getApexOrgWideCoverage();
		    	List<ApexCodeCoverageAggregate> codeCovs = getApexCodeCoverageAgg();
		    	
				// Overall code coverage
		    	Integer orgWidePercent = Utils.isNotEmpty(orgWide) ? orgWide.getPercentCovered() : 0 ;
		    	CodeCovResult ccResult = new CodeCovResult(Messages.RunTestView_CodeCoverageOverall, orgWidePercent, null, null);
		    	ccResults.add(ccResult);
		    	
		    	Pattern pattern = Pattern.compile(".*? Name='(.*?)'.*?");
		    	for (ApexCodeCoverageAggregate codeCov : codeCovs) {
		    		// Extract the class name from the toString
		    		String className = codeCov.getApexClassOrTriggerId();
		    		if (Utils.isNotEmpty(codeCov.getApexClassOrTrigger())) {
		    			className = codeCov.getApexClassOrTrigger().toString();
		        		Matcher matcher = pattern.matcher(className);
		        		className = matcher.find() ? matcher.group(1) : codeCov.getApexClassOrTriggerId();
		    		}
		    		// Get percent and lines covered
		    		Integer linesCovered = codeCov.getNumLinesCovered();
		    		Integer total = linesCovered + codeCov.getNumLinesUncovered();
		    		Integer percent = (int) Math.round(linesCovered * 100.0 / total);
		    		// Save to list
		    		ccResults.add(new CodeCovResult(className, percent, linesCovered, total));
		    	}
		    	// Update UI with code coverage
				runTestComposite.setCodeCoverage(ccResults);
			}
    	});
    }
    
    /**
     * Display code coverage from from sync test run. Use
     * the code coverage included in the sync test results
     * because ApexCodeCoverageAggregate is not updated for
     * synchronous test run.
     * @param testResults
     */
    @VisibleForTesting
	public void displaySyncCodeCoverage(final RunTestsSyncResponse testResults) {
    	if ( Utils.isEmpty(runTestComposite)) return;
    	
    	Display display = PlatformUI.getWorkbench().getDisplay();
    	display.syncExec(new Runnable() {
			@Override
			public void run() {
				List<CodeCovResult> ccResults = Lists.newArrayList();
				
				final ApexOrgWideCoverage orgWide = getApexOrgWideCoverage();
				Integer orgWidePercent = Utils.isNotEmpty(orgWide) ? orgWide.getPercentCovered() : 0 ;
		    	CodeCovResult ccResult = new CodeCovResult(Messages.RunTestView_CodeCoverageOverall, orgWidePercent, null, null);
		    	ccResults.add(ccResult);
				
				for (RunTestsSyncCodeCoverage rtscc : testResults.getCodeCoverage()) {
					String className = rtscc.getName();
					Integer linesCovered = rtscc.getNumLocations();
					Integer total = linesCovered + rtscc.getNumLocationsNotCovered();
					Integer percent = (int) Math.round(linesCovered * 100.0 / total);
					ccResults.add(new CodeCovResult(className, percent, linesCovered, total));
				}
				
				runTestComposite.setCodeCoverage(ccResults);
				
				for (RunTestsSyncCodeCoverageWarning warning : testResults.getCodeCoverageWarnings()) {
					logger.warn(String.format("Apex Class or Trigger: %s | Problem: %s", warning.getName(), warning.getMessage()));
				}
			}
    	});
    }
    
    /**
     * Create a default TreeItem for a test class.
     * @param parent
     * @param testResources
     * @param font
     * @param classId
     * @return TreeItem for test class
     */
    private TreeItem createTestClassTreeItem(Tree parent, Map<IResource, List<String>> testResources, Font font, String classId) {
    	TreeItem newClassNode = new TreeItem(parent, SWT.NONE);
		newClassNode.setFont(font);
		newClassNode.setExpanded(false);
		// Mark this test class as pass until we find a test method within it that says otherwise
		setColorAndIconForNode(newClassNode, ApexTestOutcome.Pass);
		
		// Test result only has test class ID. Find the test class name mapped to that ID to display in UI
		IResource testResource = getResourceFromId(testResources, classId);
		String className = Utils.isNotEmpty(testResource) ? testResource.getName() : classId;
		newClassNode.setText(className);
		
		// Save the associated file in the tree item
		IFile testFile = (IFile) testResource;
		if (Utils.isNotEmpty(testFile)) {
			// For test classes, always point to the first line of the file
			ApexCodeLocation location = new ApexCodeLocation(testFile, 1, 1);
			newClassNode.setData(RunTestsConstants.TREEDATA_CODE_LOCATION, location);
			Map<String, ApexCodeLocation> testMethodLocs = findTestMethods(testResource);
			if (testMethodLocs != null && testMethodLocs.size() > 0) {
				newClassNode.setData(RunTestsConstants.TREEDATA_TEST_METHOD_LOCS, testMethodLocs);
			}
		}
		
		return newClassNode;
    }
    
    /**
     * Set color and icon for a test method's TreeItem.
     * @param node
     * @param outcome
     */
    private void setColorAndIconForNode(TreeItem node, ApexTestOutcome outcome) {
    	if (Utils.isEmpty(node)|| Utils.isEmpty(outcome)) return;
    	
    	Display display = node.getDisplay();
    	if (outcome.equals(ApexTestOutcome.Pass)) {
    		node.setForeground(display.getSystemColor(RunTestsConstants.PASS_COLOR));
    		node.setImage(RunTestsConstants.PASS_ICON);
    	} else if (outcome.equals(ApexTestOutcome.Skip)) {
    		node.setForeground(display.getSystemColor(RunTestsConstants.WARNING_COLOR));
    		node.setImage(RunTestsConstants.WARNING_ICON);
    	} else {
    		node.setForeground(display.getSystemColor(RunTestsConstants.FAILURE_COLOR));
    		node.setImage(RunTestsConstants.FAILURE_ICON);
    	}
    }
    
    /**
     * Update the color & icon of a TreeItem only if the given outcome is worse than
     * what the TreeItem already indicates.
     * @param node
     * @param outcome
     */
    private void setColorAndIconForTheWorse(TreeItem node, ApexTestOutcome outcome) {
    	if (Utils.isEmpty(node) || Utils.isEmpty(outcome)) return;
    	
    	Image curImage = node.getImage();
    	boolean worseThanPass = curImage.equals(RunTestsConstants.PASS_ICON) 
    			&& !outcome.equals(ApexTestOutcome.Pass);
    	boolean worseThanWarning = curImage.equals(RunTestsConstants.WARNING_ICON) 
    			&& !outcome.equals(ApexTestOutcome.Pass) 
    			&& !outcome.equals(ApexTestOutcome.Skip);
    	if (worseThanPass || worseThanWarning) {
    		setColorAndIconForNode(node, outcome);
    	}
    }
    
    private Map<String, ApexCodeLocation> findTestMethods(IResource resource) {
		return ApexTestsUtils.INSTANCE.findTestMethodLocsInFile(resource);
	}
    
    /**
     * Create a TreeItem for a test method from an async test run
     * @param classNode
     * @param testResult
     * @param className
     * @return TreeItem for test method
     */
    private TreeItem createTestMethodTreeItem(TreeItem classNode, ApexTestResult testResult, String className) {
    	TreeItem newTestMethodNode = new TreeItem(classNode, SWT.NONE);
    	newTestMethodNode.setText(testResult.getMethodName());
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_APEX_LOG_ID, testResult.getApexLogId());
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_RESULT_MESSAGE, testResult.getMessage());
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_RESULT_STACKTRACE, testResult.getStackTrace());
    	
    	ApexCodeLocation location = getCodeLocationForTestMethod(newTestMethodNode, classNode, className, testResult.getMethodName(), testResult.getStackTrace());
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_CODE_LOCATION, location);
    	
    	return newTestMethodNode;
    }
    
    /**
     * Create a TreeItem for a test method from an sync test run
     * @param classNode
     * @param className
     * @param methodName
     * @param message
     * @param stackTrace
     * @param apexLogId
     * @return TreeItem for test method
     */
    private TreeItem createTestMethodTreeItem(TreeItem classNode, String className, String methodName, String message, String stackTrace, String apexLogId) {
    	TreeItem newTestMethodNode = new TreeItem(classNode, SWT.NONE);
    	newTestMethodNode.setText(methodName);
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_APEX_LOG_ID, apexLogId);
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_RESULT_MESSAGE, message);
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_RESULT_STACKTRACE, stackTrace);
    	
    	ApexCodeLocation location = getCodeLocationForTestMethod(newTestMethodNode, classNode, className, methodName, stackTrace);
    	newTestMethodNode.setData(RunTestsConstants.TREEDATA_CODE_LOCATION, location);
    	
    	return newTestMethodNode;
    }
    
    /**
     * Get the code location of a test method. If there isn't one, we default to
     * the code location of the test class.
     * @param treeItem
     * @param className
     * @param methodName
     * @param stackTrace
     * @return ApexCodeLocation
     */
    private ApexCodeLocation getCodeLocationForTestMethod(TreeItem methodNode, TreeItem classNode, String className, 
    		String methodName, String stackTrace) {
    	@SuppressWarnings("unchecked")
		Map<String, ApexCodeLocation> testMethodLocs = (Map<String, ApexCodeLocation>) classNode.getData(RunTestsConstants.TREEDATA_TEST_METHOD_LOCS);
    	ApexCodeLocation tmLocation = (testMethodLocs != null && testMethodLocs.containsKey(methodName)) ? 
    			testMethodLocs.get(methodName) : getLocationFromStackLine(methodName, stackTrace);
    	ApexCodeLocation tcLocation = (ApexCodeLocation) methodNode.getParentItem().getData(RunTestsConstants.TREEDATA_CODE_LOCATION);
    	// If there is no test method location, best effort is to use test class location
    	if (Utils.isEmpty(tmLocation)) {
    		tmLocation = tcLocation;
    	} else {
    		IFile file = tcLocation.getFile();
    		tmLocation.setFile(file);
    	}
    	
    	return tmLocation;
    }
    
    /**
     * Get line and column from a stack trace.
     * @param name
     * @param stackTrace
     * @return ApexCodeLocation
     */
    private ApexCodeLocation getLocationFromStackLine(String name, String stackTrace) {
        if (Utils.isEmpty(name) || Utils.isEmpty(stackTrace)) return null;

        String line = null;
        String column = null;
        try {
            String[] temp = stackTrace.split("line");
            line = temp[1].split(",")[0].trim();
            String c = temp[1].trim();
            column = c.split("column")[1].trim();
            if (Utils.isNotEmpty(column) && column.contains("\n")) {
                column = column.substring(0, column.indexOf("\n"));
            }
        } catch (Exception e) {}
        
        return new ApexCodeLocation(name, line, column);
    }
    
    /**
     * Find a resource and convert to a file.
     * @param testResources
     * @param classID
     * @return A source file
     */
    private IResource getResourceFromId(Map<IResource, List<String>> testResources, String classID) {
    	if (Utils.isNotEmpty(classID) && Utils.isNotEmpty(testResources)) {
    		for (IResource testResource : testResources.keySet()) {
    			String resourceId = ResourceProperties.getProperty(testResource, QualifiedNames.QN_ID);
    			if (resourceId.equals(classID)) {
    				return testResource;
    			}
    		}
    	}
    	
    	return null;
    }
    
    /**
     * Expand the TreeItems that did not pass.
     * @param resultsTree
     */
    private void expandProblematicTestClasses(Tree resultsTree) {
    	if (Utils.isEmpty(resultsTree)) return;
    	
    	for (TreeItem classNode : resultsTree.getItems()) {
    		if (!classNode.getImage().equals(RunTestsConstants.PASS_ICON)) {
    			classNode.setExpanded(true);
    		}
    	}
    }
    
    /**
     * Jump to and highlight a line based on the ApexCodeLocation.
     * @param location
     */
    @VisibleForTesting
    public void highlightLine(ApexCodeLocation location) {
        if (Utils.isEmpty(location) || location.getFile() == null || !location.getFile().exists()) {
            Utils.openWarn("Highlight Failed", "Unable to highlight test file - file is unknown.");
            return;
        }

        HashMap<String, Integer> map = new HashMap<>();
        map.put(IMarker.LINE_NUMBER, location.getLine());
        try {
            IMarker marker = location.getFile().createMarker(IMarker.TEXT);
            marker.setAttributes(map);
            IDE.openEditor(getSite().getWorkbenchWindow().getActivePage(), marker);
        } catch (Exception e) {
            logger.error("Unable to highlight line.", e);
            Utils.openError(new InvocationTargetException(e), true, "Unable to highlight line.");
        }
    }
    
    /**
     * Update the test results tabs.
     * @param selectedTreeItem
     * @param selectedTab
     */
    public void updateView(TreeItem selectedTreeItem, String selectedTab) {
    	if (Utils.isEmpty(selectedTreeItem) || Utils.isEmpty(selectedTab) || Utils.isEmpty(runTestComposite)) {
    		return;
    	}
    	
    	// Only clear the right side because user will either select an item from the results tree
    	// or a tab. We do not want to clear the tree (on the left side).
    	runTestComposite.clearTabs();

    	// Get the code location and open the file
    	ApexCodeLocation location = (ApexCodeLocation) selectedTreeItem.getData(RunTestsConstants.TREEDATA_CODE_LOCATION);
    	highlightLine(location);
    	
    	// Get the test result
    	String apexLogId = (String) selectedTreeItem.getData(RunTestsConstants.TREEDATA_APEX_LOG_ID);
    	String errorMessage = (String) selectedTreeItem.getData(RunTestsConstants.TREEDATA_RESULT_MESSAGE);
    	String stackTrace = (String) selectedTreeItem.getData(RunTestsConstants.TREEDATA_RESULT_STACKTRACE);
    	
    	// Check which tab is in focus so we can update lazily
    	if (selectedTab.equals(Messages.RunTestView_StackTrace)) {
    		// Stack trace only exists in a test failure
    		showStackTrace(errorMessage, stackTrace);
    	} else if (selectedTab.equals(Messages.RunTestView_SystemLog)) {
    		String apexLog = tryToGetApexLog(selectedTreeItem, apexLogId);
    		showSystemLog(apexLog);
    	} else if (selectedTab.equals(Messages.RunTestView_UserLog)) {
    		String apexLog = tryToGetApexLog(selectedTreeItem, apexLogId);
    		showUserLog(selectedTreeItem, apexLog);
    	}
    }
    
    /**
	 * Query an ApexLog with the specified log ID.
	 * @param forceProject
	 * @param logId
	 * @return ApexLog
	 */
    private ApexLog getApexLog(ForceProject forceProject, String logId) {		
		try {
			initializeConnection(forceProject);
			
			QueryResult qr = toolingStubExt.query(String.format(RunTestsConstants.QUERY_APEX_LOG, logId));
			if (qr != null && qr.getSize() == 1) {
				ApexLog apexLog = (ApexLog) qr.getRecords()[0];
				return apexLog;
			}
		} catch (ForceRemoteException | ForceConnectionException e) {}
		
		return null;
	}
	
	/**
	 * Fetch the raw body of an ApexLog with the specified log ID.
	 * @param forceProject
	 * @param logId
	 * @return Raw log. Null if something is wrong.
	 */
    private String getApexLogBody(ForceProject forceProject, String logId) {
		String rawLog = null;
		
		try {
			initializeConnection(forceProject);
			
			PromiseableJob<String> job = new ApexLogCommand(new HTTPAdapter<>(
					String.class, new ApexLogTransport(toolingRESTConnection, logId), HTTPMethod.GET));
			job.schedule();
			
			try {
				job.join();
				rawLog = job.getAnswer();
			} catch (InterruptedException e) {
				logger.error("Failed to get Apex Log", e);
			}
		} catch (ForceConnectionException | ForceRemoteException e) {
			logger.error("Failed to connect to Tooling API", e);
		}
		
		return rawLog;
	}
    
    /**
     * Get the body of an ApexLog. If that fails, get the toString of an ApexLog.
     * @param selectedTreeItem
     * @param logId
     * @return A string representation of an ApexLog
     */
    private String tryToGetApexLog(TreeItem selectedTreeItem, String logId) {
    	if (Utils.isEmpty(forceProject) || Utils.isEmpty(selectedTreeItem) || Utils.isEmpty(logId)) return null;
    	
    	// Do we already have the log body?
    	try {
    		String apexLogBody = (String) selectedTreeItem.getData(RunTestsConstants.TREEDATA_APEX_LOG_BODY);
        	if (Utils.isNotEmpty(apexLogBody)) {
        		return apexLogBody;
        	}
    	} catch (Exception e) {}
    	
    	// Try to get the log body
    	String apexLogBody = getApexLogBody(forceProject, logId);
    	if (Utils.isNotEmpty(apexLogBody)) {
    		// Save it for future uses
    		selectedTreeItem.setData(RunTestsConstants.TREEDATA_APEX_LOG_BODY, apexLogBody);
    		return apexLogBody;
    	}
    	
    	// There is no ApexLog body, so try to retrieve a saved ApexLog
    	try {
    		ApexLog apexLog = (ApexLog) selectedTreeItem.getData(RunTestsConstants.TREEDATA_APEX_LOG);
    		if (Utils.isNotEmpty(apexLog)) {
        		return apexLog.toString();
        	}
    	} catch (Exception e) {}
    	
    	// Try to get the ApexLog object
    	ApexLog apexLog = getApexLog(forceProject, logId);
    	selectedTreeItem.setData(RunTestsConstants.TREEDATA_APEX_LOG, apexLog);
    	return (Utils.isNotEmpty(apexLog) ? apexLog.toString() : null);
    }
    
    /**
     * Update the Stack Trace tab with the given error message & stack trace.
     * @param message
     * @param stackTrace
     */
    private void showStackTrace(String message, String stackTrace) {
    	if (Utils.isNotEmpty(runTestComposite)) {
    		StringBuilder data = new StringBuilder();
    		
    		if (Utils.isNotEmpty(message)) {
    			data.append(message + RunTestsConstants.NEW_LINE + RunTestsConstants.NEW_LINE);
    		}
    		
    		if (Utils.isNotEmpty(stackTrace)) {
    			data.append(stackTrace);
    		}
    		
    		runTestComposite.setStackTraceArea(data.toString());
    	}
    }
    
    /**
     * Update the System Debug Log tab with the given log.
     * @param log
     */
    private void showSystemLog(String log) {
    	if (Utils.isNotEmpty(runTestComposite) && Utils.isNotEmpty(log)) {
    		runTestComposite.setSystemLogsTextArea(log);
    	}
    }
    
    /**
     * Update the User Debug Log tab with a filtered log.
     * @param selectedTreeItem
     * @param log
     */
    private void showUserLog(TreeItem selectedTreeItem, String log) {
    	if (Utils.isEmpty(selectedTreeItem) || Utils.isEmpty(runTestComposite)) {
    		return;
    	}
    	
    	// Do we already have a filtered log?
    	try {
    		String userDebugLog = (String) selectedTreeItem.getData(RunTestsConstants.TREEDATA_APEX_LOG_USER_DEBUG);
        	if (Utils.isNotEmpty(userDebugLog)) {
        		runTestComposite.setUserLogsTextArea(userDebugLog);
        		return;
        	}
    	} catch (Exception e) {}
    	
    	// Filter the given log with only DEBUG statements
    	if (Utils.isNotEmpty(log) && log.contains("DEBUG")) {
    		String userDebugLog = "";
            String[] newDateWithSperators = log.split("\\|");
            for (int index = 0; index < newDateWithSperators.length; index++) {
                String newDateWithSperator = newDateWithSperators[index];
                if (newDateWithSperator.contains("USER_DEBUG")) {
                    String debugData = newDateWithSperators[index + 3];
                    debugData = debugData.substring(0, debugData.lastIndexOf('\n'));
                    userDebugLog += "\n" + debugData + "\n";
                }

            }
            // Save it for future uses
            selectedTreeItem.setData(RunTestsConstants.TREEDATA_APEX_LOG_USER_DEBUG, userDebugLog);
            // Update the tab
            runTestComposite.setUserLogsTextArea(userDebugLog);
    	}
    }
    
    /**
     * Get the code coverage aggregate
     * @param forceProject
     * @return ApexCodeCoverageAggregate
     */
    private List<ApexCodeCoverageAggregate> getApexCodeCoverageAgg() {
    	List<ApexCodeCoverageAggregate> codeCovs = Lists.newArrayList();
    	
		try {
			initializeConnection(forceProject);
			
			QueryResult qr = toolingStubExt.query(RunTestsConstants.QUERY_APEX_CODE_COVERAGE_AGG);
			if (qr != null) {
				for (SObject sobj : qr.getRecords()) {
					codeCovs.add((ApexCodeCoverageAggregate) sobj);
				}
			}
		} catch (ForceRemoteException | ForceConnectionException e) {}
		
		return codeCovs;
	}
    
    /**
     * Get the org wide code coverage
     * @param forceProject
     * @return ApexOrgWideCoverage
     */
    private ApexOrgWideCoverage getApexOrgWideCoverage() {		
		try {
			initializeConnection(forceProject);
			
			QueryResult qr = toolingStubExt.query(RunTestsConstants.QUERY_APEX_ORG_WIDE_COVERAGE);
			if (qr != null && qr.getSize() == 1) {
				ApexOrgWideCoverage orgWideCov = (ApexOrgWideCoverage) qr.getRecords()[0];
				return orgWideCov;
			}
		} catch (ForceRemoteException | ForceConnectionException e) {}
		
		return null;
	}
    
    /**
	 * Initialize Tooling connection.
	 * @param forceProject
	 * @throws ForceConnectionException
	 * @throws ForceRemoteException
	 */
    @VisibleForTesting
	public void initializeConnection(ForceProject forceProject) throws ForceConnectionException, ForceRemoteException {
		toolingRESTConnection = new HTTPConnection(forceProject, RunTestsConstants.TOOLING_ENDPOINT);
        toolingRESTConnection.initialize();
        toolingStubExt = ContainerDelegate.getInstance().getFactoryLocator().getToolingFactory().getToolingStubExt(forceProject);
	}
	
    /**
     * Initialize Tooling Connection with timeout
     * @param forceProject
     * @param timeout
     * @throws ForceConnectionException
     * @throws ForceRemoteException
     */
	@VisibleForTesting
	public void initializeConnection(ForceProject forceProject, int timeout) throws ForceConnectionException, ForceRemoteException {
		toolingRESTConnection = new HTTPConnection(forceProject, RunTestsConstants.TOOLING_ENDPOINT, timeout);
        toolingRESTConnection.initialize();
        toolingStubExt = ContainerDelegate.getInstance().getFactoryLocator().getToolingFactory().getToolingStubExt(forceProject);
	}
    
	private void setProject(IProject project) {
    	this.project = project;
    	this.runTestComposite.setProject(project);
    	this.runTestComposite.enableComposite();
    }

	@VisibleForTesting
	public RunTestsViewComposite getRunTestComposite() {
        return runTestComposite;
    }
    
    @Override
    public void dispose() {
        super.dispose();
        getSite().getPage().removeSelectionListener(fPostSelectionListener);
    }
    
    @Override
    public void createPartControl(Composite parent) {
        runTestComposite = new RunTestsViewComposite(parent, SWT.NONE, this);
        setPartName(Messages.RunTestView_Name);
        setTitleImage(getImage());

        UIUtils.setHelpContext(runTestComposite, this.getClass().getSimpleName());
    }

    @Override
    public void setFocus() {
        if (Utils.isNotEmpty(runTestComposite)) {
            runTestComposite.setFocus();
        }
    }
    
    private void setSelectionListener() {
        fPostSelectionListener = new ISelectionListener() {
            @Override
            public void selectionChanged(IWorkbenchPart part, ISelection selection) {
                project = getProjectService().getProject(selection);
                if (selection instanceof IStructuredSelection) {
                    IStructuredSelection ss = (IStructuredSelection) selection;
                    Object selElement = ss.getFirstElement();
                    if (selElement instanceof IResource) {
                    	setProject(((IResource) selElement).getProject());
                    }
                }
            }
        };
    }
    
    public class CodeCovResult {
    	private final String className;
    	private final Integer percent;
    	private final Integer linesCovered;
    	private final Integer linesTotal;
    	private final Integer linesNotCovered;
    	
    	public CodeCovResult(String className, Integer percent, Integer linesCovered, Integer linesTotal) {
    		this.className = className;
    		this.percent = percent;
    		this.linesCovered = linesCovered;
    		this.linesTotal = linesTotal;
    		this.linesNotCovered = (Utils.isNotEmpty(linesTotal) && Utils.isNotEmpty(linesCovered)) ? linesTotal - linesCovered : 0;
    	}
    	
    	public String getClassName() {
    		return this.className;
    	}
    	
    	public Integer getPercent() {
    		return this.percent;
    	}
    	
    	public Integer getLinesCovered() {
    		return this.linesCovered;
    	}
    	
    	public Integer getLinesTotal() {
    		return this.linesTotal;
    	}
    	
    	public Integer getLinesNotCovered() {
    		return this.linesNotCovered;
    	}
    }
    
    public static class CodeCovComparators {
    	public static Comparator<CodeCovResult> CLASSNAME_ASC = sortByTypeWithDirection(Messages.RunTestView_CodeCoverageClass, -1);
    	public static Comparator<CodeCovResult> PERCENT_ASC = sortByTypeWithDirection(Messages.RunTestView_CodeCoveragePercent, -1);
    	public static Comparator<CodeCovResult> LINES_ASC = sortByTypeWithDirection(Messages.RunTestView_CodeCoverageLines, -1);
    	public static Comparator<CodeCovResult> CLASSNAME_DESC = sortByTypeWithDirection(Messages.RunTestView_CodeCoverageClass, 1);
    	public static Comparator<CodeCovResult> PERCENT_DESC = sortByTypeWithDirection(Messages.RunTestView_CodeCoveragePercent, 1);
    	public static Comparator<CodeCovResult> LINES_DESC = sortByTypeWithDirection(Messages.RunTestView_CodeCoverageLines, 1);
    	
    	private static Comparator<CodeCovResult> sortByTypeWithDirection(final String type, final int direction) {
    		return new Comparator<CodeCovResult>() {
    			@Override
    			public int compare(CodeCovResult o1, CodeCovResult o2) {
    				if (o1.getClassName().equals(Messages.RunTestView_CodeCoverageOverall)) return -1;
    				if (o2.getClassName().equals(Messages.RunTestView_CodeCoverageOverall)) return 1;
    				
    				int compareDir = -1;
    				if (type.equals(Messages.RunTestView_CodeCoveragePercent)) {
    					compareDir = o1.getPercent().compareTo(o2.getPercent());
    				} else if (type.equals(Messages.RunTestView_CodeCoverageLines)) {
    					compareDir = o1.getLinesTotal().compareTo(o2.getLinesTotal());
    				} else {
    					compareDir = o1.getClassName().compareTo(o2.getClassName());
    				}
    				
    				if (direction > 0) {
    					compareDir *= -1;
    				}
    				
    				return compareDir;
    			}
        	};
    	}
    }
}
